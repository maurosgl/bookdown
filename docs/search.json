[{"path":"index.html","id":"intro","chapter":"Capítulo 1 Introducción","heading":"Capítulo 1 Introducción","text":"Time Series Price Vegetables Fruits\nEl conjunto de datos “Time Series Price Vegetables Fruits” contiene información oficial sobre los precios diarios de las principales frutas y verduras en Nepal entre 2013 y 2021 de una fuente oficial del gobierno (Kalimati), compilada en un repositorio público Kaggle.Commodity: Nombre de las frutas o vegetalesDate: Fecha en formato año - mes – díaUnit: Unidad de medida (Kg)Minimum: Precio mínimo registrado de venta del díaMaximum: Precio máximo registrado de venta del díaAverage: Precio promedio de venta del díaAnalizar y predecir el precio de productos agrícolas es fundamental para poder tomar decisiones informadas, asignar los recursos de una manera óptima y contribuir al crecimiento económico del agro. Por la dinámica de los precios en frutas y verduras, que se encuentra condicionada por temporadas de cosecha, factores climáticos y la relación entre oferta y demanda, resulta complejo proyectar precios de manera certera. Con modelos tradicionales de análisis, captar patrones puede ser difícil; sin embargo, esta limitación puede superarse mediante técnicas de machine learning aplicadas series de tiempo.La selección del dataset se debe al carácter temporal y la granularidad de los datos, lo que facilita hallar tendencias y estacionalidades en los precios, emplear datos históricos para predecir precios futuros, así como detectar patrones inusuales o anomalías en los datos. Otro valor importante que puede lograrse través del análisis del conjunto de datos es el desarrollo de estrategias de precios basadas en los patrones hallados.","code":""},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"eda-y-análisis-de-series-de-tiempo","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"Capítulo 2 EDA y Análisis de Series de tiempo","text":"","code":""},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"cargue-de-datos","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.0.1 Cargue de Datos","text":"Realizaremos nuestro analisis con un conjunto de datos de precios agrícolas proveniente del mercado de Kalimati (Nepal). Este dataset incluye información diaria sobre productos agrícolas, sus precios mínimos, máximos y promedio. partir de estos datos se realizará un análisis exploratorio y un estudio de comportamiento temporal de los precios.","code":"\n# Librerias (base originales + necesarias)\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(ggplot2)\nlibrary(forecast)\nlibrary(tseries)\nlibrary(here)    # rutas reproducibles\nlibrary(tidyr)   # regularizar fechas (complete)\nlibrary(slider)  # promedios moviles\ncsv_file <- \"C:/Users/Steba/OneDrive/Escritorio/kalimati_tarkari_dataset (2).csv\"\n# Leer datos\n\ndata_raw <- readr::read_csv(csv_file, show_col_types = FALSE)\n\n# Estandarizar nombres a snake para facilitar mapeo\n\nnms <- tolower(gsub(\"[^a-zA-Z0-9]+\", \"_\", names(data_raw)))\n\n# Intentar mapear columnas canonicas (Commodity / Date / Minimum / Maximum / Average)\n\ndf <- data_raw\nnames(df) <- nms\n\n# Mapeo flexible (case-insensitive)\n\npick_first <- function(cands) {\nhit <- intersect(cands, names(df))\nif (length(hit) == 0) return(NA_character_) else return(hit[1])\n}\n\ncol_commodity <- pick_first(c(\"commodity\",\"item\",\"product\",\"variety\",\"name\"))\ncol_date      <- pick_first(c(\"date\",\"fecha\",\"day\"))\ncol_min       <- pick_first(c(\"minimum\",\"min\",\"min_price\",\"price_min\"))\ncol_max       <- pick_first(c(\"maximum\",\"max\",\"max_price\",\"price_max\"))\ncol_avg       <- pick_first(c(\"average\",\"avg\",\"avg_price\",\"price_avg\",\"mean_price\"))\n\nreq <- c(col_commodity, col_date, col_min, col_max, col_avg)\n\nif (any(is.na(req))) {\nstop(\"No fue posible mapear columnas clave (commodity/date/min/max/average). Revisa nombres del CSV: \",\npaste(names(df), collapse = \", \"))\n}\n\ndata <- df %>%\ntransmute(\nCommodity = .data[[col_commodity]],\nDate      = as.Date(.data[[col_date]]),\nUnit      = NA_character_,                 # si no existe, queda NA (no se usa en el analisis)\nMinimum   = as.numeric(.data[[col_min]]),\nMaximum   = as.numeric(.data[[col_max]]),\nAverage   = as.numeric(.data[[col_avg]])\n)\n\n# Chequeos basicos\n\nstopifnot(inherits(data$Date, \"Date\"))"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"primera-visualización-de-los-datos","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.0.2 Primera Visualización de los datos","text":"","code":"\n# Vista previa y estructura\n\nhead(data)## # A tibble: 6 × 6\n##   Commodity           Date       Unit  Minimum Maximum Average\n##   <chr>               <date>     <chr>   <dbl>   <dbl>   <dbl>\n## 1 Tomato Big(Nepali)  2013-06-16 <NA>       35      40    37.5\n## 2 Tomato Small(Local) 2013-06-16 <NA>       26      32    29  \n## 3 Potato Red          2013-06-16 <NA>       20      21    20.5\n## 4 Potato White        2013-06-16 <NA>       15      16    15.5\n## 5 Onion Dry (Indian)  2013-06-16 <NA>       28      30    29  \n## 6 Carrot(Local)       2013-06-16 <NA>       30      35    32.5\nstr(data)## tibble [197,161 × 6] (S3: tbl_df/tbl/data.frame)\n##  $ Commodity: chr [1:197161] \"Tomato Big(Nepali)\" \"Tomato Small(Local)\" \"Potato Red\" \"Potato White\" ...\n##  $ Date     : Date[1:197161], format: \"2013-06-16\" \"2013-06-16\" ...\n##  $ Unit     : chr [1:197161] NA NA NA NA ...\n##  $ Minimum  : num [1:197161] 35 26 20 15 28 30 6 30 35 25 ...\n##  $ Maximum  : num [1:197161] 40 32 21 16 30 35 10 35 40 30 ...\n##  $ Average  : num [1:197161] 37.5 29 20.5 15.5 29 32.5 8 32.5 37.5 27.5 ...\nsummary(data)##   Commodity              Date                Unit              Minimum       \n##  Length:197161      Min.   :2013-06-16   Length:197161      Min.   :   1.00  \n##  Class :character   1st Qu.:2015-08-24   Class :character   1st Qu.:  40.00  \n##  Mode  :character   Median :2017-08-03   Mode  :character   Median :  60.00  \n##                     Mean   :2017-08-09                      Mean   :  85.42  \n##                     3rd Qu.:2019-08-27                      3rd Qu.: 100.00  \n##                     Max.   :2021-05-13                      Max.   :1800.00  \n##     Maximum           Average       \n##  Min.   :   6.00   Min.   :   5.00  \n##  1st Qu.:  45.00   1st Qu.:  42.50  \n##  Median :  70.00   Median :  65.00  \n##  Mean   :  94.16   Mean   :  89.79  \n##  3rd Qu.: 110.00   3rd Qu.: 105.00  \n##  Max.   :2000.00   Max.   :1900.00"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"datos-faltantes-y-duplicados","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.0.3 Datos faltantes y duplicados","text":"","code":"\n# NAs y duplicados generales\n\nsum(is.na(data))## [1] 197161\nsum(duplicated(data))## [1] 0"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"análisis-univariado","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.0.4 Análisis Univariado","text":"","code":"\n#analisis univariado\n\nggplot(data, aes(x = Average)) +\ngeom_histogram(binwidth = 5, fill = \"blue\", color = \"black\", alpha = 0.7) +\nlabs(title = \"Distribucion de Precios Promedio\", x = \"Precio Promedio\", y = \"Frecuencia\") +\ntheme_minimal()\ndata %>%\nsummarise(\nMean = mean(Average, na.rm = TRUE),\nMedian = median(Average, na.rm = TRUE),\nSD = sd(Average, na.rm = TRUE),\nMin = min(Average, na.rm = TRUE),\nMax = max(Average, na.rm = TRUE)\n)## # A tibble: 1 × 5\n##    Mean Median    SD   Min   Max\n##   <dbl>  <dbl> <dbl> <dbl> <dbl>\n## 1  89.8     65  79.6     5  1900"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"análisis-bivariado","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.0.5 Análisis Bivariado","text":"","code":"\n#analisis bivariado\n\nggplot(data, aes(x = Minimum, y = Maximum)) +\ngeom_point(alpha = 0.5) +\nlabs(title = \"Relacion entre Precio Minimo y Maximo\", x = \"Precio Minimo\", y = \"Precio Maximo\") +\ntheme_minimal()"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"correlación-de-los-datos","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.0.6 Correlación de los datos","text":"","code":"\ncor(data$Minimum, data$Maximum, use = \"complete.obs\")## [1] 0.9950614"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"analisis-de-series-de-tiempo","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.1 Analisis de series de tiempo","text":"","code":"\nif (\"Potato Red\" %in% unique(data$Commodity)) {\ntarget_item <- \"Potato Red\"\n} else {\ntarget_item <- data %>%\ncount(Commodity, sort = TRUE) %>%\nslice(1) %>%\npull(Commodity)\n}\n\ntarget_item## [1] \"Potato Red\"\n# Filtrar y regularizar serie diaria\n\npotatored <- data %>%\nfilter(Commodity == target_item) %>%\nselect(Date, Average) %>%\ngroup_by(Date) %>%\nsummarise(Average = mean(Average), .groups = \"drop\") %>%\ncomplete(Date = seq(min(Date, na.rm = TRUE), max(Date, na.rm = TRUE), by = \"day\")) %>%\narrange(Date)\n\n# Construir objeto ts (diario, 365)\n\npot_ts <- ts(\npotatored$Average,\nstart = c(lubridate::year(min(potatored$Date, na.rm = TRUE)),\nlubridate::yday(min(potatored$Date, na.rm = TRUE))),\nfrequency = 365\n)"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"serie-basica-y-acf","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.1.1 Serie basica y ACF","text":"","code":"\nautoplot(pot_ts) +\nlabs(title = \"Serie de tiempo: precio promedio\", y = \"Precio promedio\") +\ntheme_minimal()\nggAcf(pot_ts) + labs(title = \"ACF del precio promedio (diario)\")"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"promedios-moviles-evidencia-de-suavizado","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.1.2 Promedios moviles (evidencia de suavizado)","text":"","code":"\npot_ma <- potatored %>%\n  mutate(\n    ma7  = slide_dbl(Average, mean, .before = 6,  .complete = TRUE),\n    ma30 = slide_dbl(Average, mean, .before = 29, .complete = TRUE)\n  )\n\nggplot(pot_ma, aes(Date, Average)) +\n  geom_line(linewidth = 0.5, alpha = 0.6) +\n  geom_line(aes(y = ma7),  linewidth = 0.8) +\n  geom_line(aes(y = ma30), linewidth = 0.9) +\n  labs(title = \"Serie y promedios moviles (7 y 30 dias)\",\n       x = \"Fecha\", y = \"Precio promedio\") +\n  theme_minimal()"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"rezagos-lags-y-dependencia-temporal","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.1.3 Rezagos (lags) y dependencia temporal","text":"","code":"\npot_lags <- potatored %>%\n  mutate(\n    lag1  = dplyr::lag(Average, 1),\n    lag7  = dplyr::lag(Average, 7),\n    lag30 = dplyr::lag(Average, 30)\n  )\n\n# Scatter y_t vs y_{t-1}\nggplot(pot_lags, aes(lag1, Average)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(method = \"lm\", se = FALSE, linewidth = 0.7) +\n  theme_minimal() +\n  labs(title = \"Scatter rezago 1 (y_t vs y_{t-1})\", x = \"y_{t-1}\", y = \"y_t\")\n# Scatter y_t vs y_{t-7}\nggplot(pot_lags, aes(lag7, Average)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(method = \"lm\", se = FALSE, linewidth = 0.7) +\n  theme_minimal() +\n  labs(title = \"Scatter rezago 7 (aprox. semanal)\", x = \"y_{t-7}\", y = \"y_t\")\n# ACF/PACF (serie regularizada)\n\nggAcf(pot_ts)  + labs(title = \"ACF precio promedio (diario)\")\nggPacf(pot_ts) + labs(title = \"PACF precio promedio (diario)\")"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"estacionalidad-descomposicion-stl","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.1.4 Estacionalidad (descomposicion STL)","text":"El estudio de rezagos (lag 1, lag 7 y lag 30) refuerza esta observación: las gráficas de dispersión muestran una clara autocorrelación positiva, especialmente para rezagos cortos, indicando que los precios actuales dependen directamente de los valores recientes. Este comportamiento sugiere persistencia temporal: cuando los precios aumentan o disminuyen, tienden mantener esa dirección durante varios días, lo cual es característico de mercados donde la información y las condiciones de oferta cambian abruptamente.La función de autocorrelación (ACF) confirma esta dependencia temporal, con correlaciones significativas en los primeros rezagos que luego disminuyen de forma progresiva. Esto demuestra que la serie sigue un comportamiento completamente aleatorio, sino que existen patrones repetitivos en el tiempo.La descomposición STL separó la serie en sus componentes de tendencia, estacionalidad y residuo. Los resultados muestran una estacionalidad marcada con ciclos anuales definidos: los precios tienden elevarse en ciertas épocas del año y disminuir en otras, reflejando los periodos de cosecha y escasez. La tendencia general es estable con una leve inclinación al alza, mientras que los residuos mantienen una magnitud baja y presentan patrones visibles, lo que indica que gran parte de la variabilidad del precio está explicada por la tendencia y la estacionalidad, sin presencia de choques exógenos significativos.En conjunto, estos hallazgos evidencian que la serie del precio promedio de Potato Red posee un comportamiento estacionario, con una tendencia creciente y estacionalidad recurrente, pero sin irregularidades fuertes.\nEl patrón identificado sugiere que los precios pueden modelarse de forma confiable mediante técnicas de suavizado exponencial o modelos ARIMA estacionales, una vez que se realicen las transformaciones necesarias para estabilizar la media y la varianza. En términos prácticos, los resultados reflejan que el mercado analizado responde ciclos previsibles, lo cual facilita la planificación de precios, abastecimiento y estrategias de comercialización.","code":"\nfit_stl <- stl(na.interp(pot_ts), s.window = \"periodic\", robust = TRUE)\nautoplot(fit_stl) + labs(title = \"STL precio promedio\")"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"estacionariedad-y-diferenciación","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.1.5 Estacionariedad y diferenciación","text":"Introducción\nEn esta segunda parte se busca analizar si la serie de tiempo seleccionada (Potato Red) cumple con el supuesto de estacionariedad. Una serie estacionaria es aquella cuya media y varianza permanecen constantes en el tiempo.\nEn caso de que sea estacionaria, se aplicarán procedimientos de diferenciación # o transformación para estabilizar la tendencia y la variabilidad.","code":"\n# Usaremos una version \"limpia\" de la serie via interpolacion lineal base R, partimos de 'potatored' (data.frame terminado) y/o de 'pot_ts' (ts original)\n\ny <- as.numeric(pot_ts)\n\nif (anyNA(y)) {\n  idx_ok <- which(!is.na(y))\n  y_interp <- approx(x = idx_ok, y = y[idx_ok], xout = seq_along(y))$y\n} else {\n  y_interp <- y}\n\n\npot_ts_clean <- ts(\n  y_interp,\n  start = start(pot_ts),\n  frequency = frequency(pot_ts)\n)"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"verificación-de-estacionariedad-adf-test","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.1.6 Verificación de estacionariedad (ADF Test)","text":"La transformación logarítmica ayudó homogeneizar la variabilidad, pero eliminó la tendencia ni la dependencia temporal. La serie transformada sigue teniendo raíz unitaria, por lo que pasamos una diferenciacion de primer orden (d=1) sobre la serie logaritmica y volvemos probar estacionariedad.con este resultado podemos concluir que:La serie original era estacionaria (p = 0.1301).La serie original era estacionaria (p = 0.1301).La serie logarítmica tampoco lo fue (p = 0.1322), aunque esa transformación ayudó estabilizar la varianzaLa serie logarítmica tampoco lo fue (p = 0.1322), aunque esa transformación ayudó estabilizar la varianzaAl aplicar una diferencia de primer orden sobre la serie logarítmica, la prueba ADF arrojó p = 0.01, es decir < 0.05, por lo tanto sí es estacionaria.Al aplicar una diferencia de primer orden sobre la serie logarítmica, la prueba ADF arrojó p = 0.01, es decir < 0.05, por lo tanto sí es estacionaria.","code":"\n# Prueba de raíz unitaria de Dickey-Fuller aumentada\n\nadf_result <- adf.test(pot_ts_clean)\nadf_result## \n##  Augmented Dickey-Fuller Test\n## \n## data:  pot_ts_clean\n## Dickey-Fuller = -3.0587, Lag order = 14, p-value = 0.1301\n## alternative hypothesis: stationary\n# al tener en el ADF inicial: p = 0.1301 → se concluye que es no estacionaria al nive, por lo cual procedemos con transformacion y diferenciacion en escalones\n\n\n# Serie base a usar en esta etapa y verificamos que no tenga na ni valores negativos\ny0 <- pot_ts_clean \nsum(is.na(y0))## [1] 0\nall(y0>0)## [1] TRUE\ny_log <- log(y0)\nrange(y0, na.rm = TRUE); range(y_log, na.rm = TRUE)  # solo para verificar el cambio de escala## [1]  15.0 113.5## [1] 2.708050 4.731803\nadf_log <- adf.test(y_log)\nadf_log$p.value## [1] 0.1322035\ny_diff1 <- diff(y_log, differences = 1)\nadf_diff1 <- tseries::adf.test(na.omit(y_diff1))\nadf_diff1$p.value## [1] 0.01"},{"path":"eda-y-análisis-de-series-de-tiempo.html","id":"interpretacion","chapter":"Capítulo 2 EDA y Análisis de Series de tiempo","heading":"2.1.7 Interpretacion","text":"Luego de aplicar la transformación logarítmica, la serie mantuvo la misma tendencia general, por lo que se logró estacionariedad. Sin embargo, al diferenciarla una vez (d = 1), la prueba de Dickey–Fuller aumentada mostró un p-valor de 0.01, lo que indica que se rechaza la hipótesis nula de raíz unitaria. En consecuencia, la serie diferenciada es estacionaria.Este resultado implica que la tendencia determinista fue eliminada mediante la primera diferencia, estabilizando la media lo largo del tiempo. Por otro lado, la transformación logarítmica permitió controlar la heterocedasticidad, de modo que las fluctuaciones de la serie ahora son de magnitud comparable. La combinación de ambos pasos —logaritmo y diferencia de primer orden— produce una serie adecuada para modelar mediante métodos lineales, como los modelos ARIMA o SARIMA.Visualmente, la serie diferenciada oscila alrededor de cero y las funciones de autocorrelación (ACF y PACF) se estabilizan rápidamente, lo que refuerza la evidencia de estacionariedad.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"pronóstico-de-demanda-holtwinters","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"Capítulo 3 Pronóstico de Demanda HoltWinters","text":"Este análisis aborda el pronóstico de los precios del “Potato Red” del mercado de Kalimati. Inicia con la carga, limpieza y un análisis exploratorio (EDA) para identificar tendencias y estacionalidad. Dada la alta frecuencia de los datos diarios, la serie se agrega un formato semanal (frecuencia 52) para permitir un modelado estable. Posteriormente, se comparan varios métodos de suavizamiento exponencial (SES, Holt, Holt-Winters Aditivo y Multiplicativo) en conjuntos de entrenamiento y prueba. Finalmente, se selecciona el modelo Holt-Winters Multiplicativo, basado en su precisión (RMSE/MAPE), para generar un pronóstico validado 52 semanas.Realizaremos nuestro analisis con un conjunto de datos de precios agrícolas proveniente del mercado de Kalimati (Nepal). Este dataset incluye información diaria sobre productos agrícolas, sus precios mínimos, máximos y promedio. partir de estos datos se realizará un análisis exploratorio y un estudio de comportamiento temporal de los precios.","code":"\n# Librerias (base originales + necesarias)\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(ggplot2)\nlibrary(forecast)\nlibrary(tseries)\nlibrary(here)    # rutas reproducibles\nlibrary(tidyr)   # regularizar fechas (complete)\nlibrary(slider)  # promedios moviles\ncsv_file <- \"C:/Users/Steba/OneDrive/Escritorio/kalimati_tarkari_dataset (2).csv\"\n# Leer datos\n\ndata_raw <- readr::read_csv(csv_file, show_col_types = FALSE)\n\n# Estandarizar nombres a snake para facilitar mapeo\n\nnms <- tolower(gsub(\"[^a-zA-Z0-9]+\", \"_\", names(data_raw)))\n\n# Intentar mapear columnas canonicas (Commodity / Date / Minimum / Maximum / Average)\n\ndf <- data_raw\nnames(df) <- nms\n\n# Mapeo flexible (case-insensitive)\n\npick_first <- function(cands) {\nhit <- intersect(cands, names(df))\nif (length(hit) == 0) return(NA_character_) else return(hit[1])\n}\n\ncol_commodity <- pick_first(c(\"commodity\",\"item\",\"product\",\"variety\",\"name\"))\ncol_date      <- pick_first(c(\"date\",\"fecha\",\"day\"))\ncol_min       <- pick_first(c(\"minimum\",\"min\",\"min_price\",\"price_min\"))\ncol_max       <- pick_first(c(\"maximum\",\"max\",\"max_price\",\"price_max\"))\ncol_avg       <- pick_first(c(\"average\",\"avg\",\"avg_price\",\"price_avg\",\"mean_price\"))\n\nreq <- c(col_commodity, col_date, col_min, col_max, col_avg)\n\nif (any(is.na(req))) {\nstop(\"No fue posible mapear columnas clave (commodity/date/min/max/average). Revisa nombres del CSV: \",\npaste(names(df), collapse = \", \"))\n}\n\ndata <- df %>%\ntransmute(\nCommodity = .data[[col_commodity]],\nDate      = as.Date(.data[[col_date]]),\nUnit      = NA_character_,                 # si no existe, queda NA (no se usa en el analisis)\nMinimum   = as.numeric(.data[[col_min]]),\nMaximum   = as.numeric(.data[[col_max]]),\nAverage   = as.numeric(.data[[col_avg]])\n)\n\n# Chequeos basicos\n\nstopifnot(inherits(data$Date, \"Date\"))"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"analisis-de-series-de-tiempo-1","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.1 Analisis de series de tiempo","text":"","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"selección-del-item-objetivo","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.1.1 Selección del item objetivo","text":"Se selecciona el producto analizar. El código prioriza “Potato Red”, pero si existe, selecciona el producto con más observaciones mediante (count(Commodity, sort = TRUE))Una vez se cuenta con el dataset filtrado para el item “Potato Red”, mediante broupby y summarise se asegura que sólo exista un precio promedio por día evitando conflictos con entreadas duplicadas. Mediante complete() además se regulariza la serie temporal, insertando filas con NA para los días faltantes en el rango de fechas. Además se cponstruye la Serie de tiempos diaria para evaluar el comportamiento inicialmente.","code":"\nif (\"Potato Red\" %in% unique(data$Commodity)) {\ntarget_item <- \"Potato Red\"\n} else {\ntarget_item <- data %>%\ncount(Commodity, sort = TRUE) %>%\nslice(1) %>%\npull(Commodity)\n}\n\ntarget_item## [1] \"Potato Red\"\n# Filtrar y regularizar serie diaria\n\npotatored <- data %>%\nfilter(Commodity == target_item) %>%\nselect(Date, Average) %>%\ngroup_by(Date) %>%\nsummarise(Average = mean(Average), .groups = \"drop\") %>%\ncomplete(Date = seq(min(Date, na.rm = TRUE), max(Date, na.rm = TRUE), by = \"day\")) %>%\narrange(Date)\n\n# Construir objeto ts (diario, 365)\n\npot_ts <- ts(\npotatored$Average,\nstart = c(lubridate::year(min(potatored$Date, na.rm = TRUE)),\nlubridate::yday(min(potatored$Date, na.rm = TRUE))),\nfrequency = 365\n)"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"serie-basica-y-acf-1","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.1.2 Serie basica y ACF","text":"continuación mediante autoplot se observa la tenedencia y la estacionalidad anual.","code":"\nautoplot(pot_ts) +\nlabs(title = \"Serie de tiempo: precio promedio\", y = \"Precio promedio\") +\ntheme_minimal()\nggAcf(pot_ts) + labs(title = \"ACF del precio promedio (diario)\")"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"promedios-moviles-evidencia-de-suavizado-1","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.1.3 Promedios moviles (evidencia de suavizado)","text":"","code":"\npot_ma <- potatored %>%\n  mutate(\n    ma7  = slide_dbl(Average, mean, .before = 6,  .complete = TRUE),\n    ma30 = slide_dbl(Average, mean, .before = 29, .complete = TRUE)\n  )\n\nggplot(pot_ma, aes(Date, Average)) +\n  geom_line(linewidth = 0.5, alpha = 0.6) +\n  geom_line(aes(y = ma7),  linewidth = 0.8) +\n  geom_line(aes(y = ma30), linewidth = 0.9) +\n  labs(title = \"Serie y promedios moviles (7 y 30 dias)\",\n       x = \"Fecha\", y = \"Precio promedio\") +\n  theme_minimal()"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"rezagos-lags-y-dependencia-temporal-1","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.1.4 Rezagos (lags) y dependencia temporal","text":"El estudio de rezagos (lag 1, lag 7 y lag 30) refuerza esta observación: las gráficas de dispersión muestran una clara autocorrelación positiva, especialmente para rezagos cortos, indicando que los precios actuales dependen directamente de los valores recientes. Este comportamiento sugiere persistencia temporal: cuando los precios aumentan o disminuyen, tienden mantener esa dirección durante varios días, lo cual es característico de mercados donde la información y las condiciones de oferta cambian abruptamente.","code":"\npot_lags <- potatored %>%\n  mutate(\n    lag1  = dplyr::lag(Average, 1),\n    lag7  = dplyr::lag(Average, 7),\n    lag30 = dplyr::lag(Average, 30)\n  )\n\n# Scatter y_t vs y_{t-1}\nggplot(pot_lags, aes(lag1, Average)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(method = \"lm\", se = FALSE, linewidth = 0.7) +\n  theme_minimal() +\n  labs(title = \"Scatter rezago 1 (y_t vs y_{t-1})\", x = \"y_{t-1}\", y = \"y_t\")\n# Scatter y_t vs y_{t-7}\nggplot(pot_lags, aes(lag7, Average)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(method = \"lm\", se = FALSE, linewidth = 0.7) +\n  theme_minimal() +\n  labs(title = \"Scatter rezago 7 (aprox. semanal)\", x = \"y_{t-7}\", y = \"y_t\")\n# ACF/PACF (serie regularizada)\n\nggAcf(pot_ts)  + labs(title = \"ACF precio promedio (diario)\")\nggPacf(pot_ts) + labs(title = \"PACF precio promedio (diario)\")"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"estacionalidad-descomposicion-stl-1","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.1.5 Estacionalidad (descomposicion STL)","text":"","code":"\nfit_stl <- stl(na.interp(pot_ts), s.window = \"periodic\", robust = TRUE)\nautoplot(fit_stl) + labs(title = \"STL precio promedio\")"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"análisis-conglomerado","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.1.6 Análisis Conglomerado","text":"En conjunto, estos hallazgos evidencian que la serie del precio promedio de Potato Red posee un comportamiento estacionario, con una tendencia creciente y estacionalidad recurrente, pero sin irregularidades fuertes.\nEl patrón identificado sugiere que los precios pueden modelarse de forma confiable mediante técnicas de suavizado exponencial o modelos ARIMA estacionales, una vez que se realicen las transformaciones necesarias para estabilizar la media y la varianza. En términos prácticos, los resultados reflejan que el mercado analizado responde ciclos previsibles, lo cual facilita la planificación de precios, abastecimiento y estrategias de comercialización.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"estacionariedad-y-diferenciación-1","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.2 Estacionariedad y diferenciación","text":"En esta segunda parte se busca analizar si la serie de tiempo seleccionada (Potato Red) cumple con el supuesto de estacionariedad. Una serie estacionaria es aquella cuya media y varianza permanecen constantes en el tiempo.\nEn caso de que sea estacionaria, se aplicarán procedimientos de diferenciación # o transformación para estabilizar la tendencia y la variabilidad.","code":"\ny <- as.numeric(pot_ts)\n\nif (anyNA(y)) {\n  idx_ok <- which(!is.na(y))\n  y_interp <- approx(x = idx_ok, y = y[idx_ok], xout = seq_along(y))$y\n} else {\n  y_interp <- y}\n\n\npot_ts_clean <- ts(\n  y_interp,\n  start = start(pot_ts),\n  frequency = frequency(pot_ts)\n)"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"verificación-de-estacionariedad-adf-test-1","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.2.1 Verificación de estacionariedad (ADF Test)","text":"El p-valor es 0.13. Como p > 0.05, podemos rechazar la H_0. Esto confirma estadísticamente lo que vimos en el ACF: la serie es estacionaria y necesita ser diferenciada.Se aplica una transformación logarítmica. Esto corrige la tendencia, sino que ayuda estabilizar la varianza. Es común en series de precios donde las fluctuaciones crecen medida que el precio sube. Como era de esperar, la serie logarítmica sigue siendo estacionaria (p=0.13).La transformación logarítmica ayudó homogeneizar la variabilidad, pero eliminó la tendencia ni la dependencia temporal. La serie transformada sigue teniendo raíz unitaria, por lo que pasamos una diferenciacion de primer orden (d=1) sobre la serie logaritmica y volvemos probar estacionariedad.Se aplica una primera diferencia la serie logarítmica, buscando eliminar la tendencia. Tras realizar la prueba adf nuevamente, es posible determinar que el p-valor es 0.01. Como p < 0.05, rechazamos la H_0. Concluimos que la serie transformada es estacionaria.","code":"\n# Prueba de raíz unitaria de Dickey-Fuller\n\nadf_result <- adf.test(pot_ts_clean)\nadf_result## \n##  Augmented Dickey-Fuller Test\n## \n## data:  pot_ts_clean\n## Dickey-Fuller = -3.0587, Lag order = 14, p-value = 0.1301\n## alternative hypothesis: stationary\n# Serie base a usar en esta etapa y verificamos que no tenga na ni valores negativos\ny0 <- pot_ts_clean \nsum(is.na(y0))## [1] 0\nall(y0>0)## [1] TRUE\ny_log <- log(y0)\nrange(y0, na.rm = TRUE); range(y_log, na.rm = TRUE)  # solo para verificar el cambio de escala## [1]  15.0 113.5## [1] 2.708050 4.731803\nadf_log <- adf.test(y_log)\nadf_log$p.value## [1] 0.1322035\ny_diff1 <- diff(y_log, differences = 1)\nadf_diff1 <- tseries::adf.test(na.omit(y_diff1))\nadf_diff1$p.value## [1] 0.01"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"interpretacion-1","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.2.2 Interpretacion","text":"Luego de aplicar la transformación logarítmica, la serie mantuvo la misma tendencia general, por lo que se logró estacionariedad. Sin embargo, al diferenciarla una vez (d = 1), la prueba de Dickey–Fuller aumentada mostró un p-valor de 0.01, lo que indica que se rechaza la hipótesis nula de raíz unitaria. En consecuencia, la serie diferenciada es estacionaria.Este resultado implica que la tendencia determinista fue eliminada mediante la primera diferencia, estabilizando la media lo largo del tiempo. Por otro lado, la transformación logarítmica permitió controlar la heterocedasticidad, de modo que las fluctuaciones de la serie ahora son de magnitud comparable. La combinación de ambos pasos —logaritmo y diferencia de primer orden— produce una serie adecuada para modelar mediante métodos lineales, como los modelos ARIMA o SARIMA.Visualmente, la serie diferenciada oscila alrededor de cero y las funciones de autocorrelación (ACF y PACF) se estabilizan rápidamente, lo que refuerza la evidencia de estacionariedad.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"suavizamiento-y-holt-winters-sobre-la-variable-tiempo","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.3 Suavizamiento y Holt-Winters sobre la variable tiempo","text":"","code":"\ny_hw <- na.interp(pot_ts) \nfreq <- frequency(y_hw)   \nlength(y_hw); freq## [1] 2889## [1] 365"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"particion-de-entrenamiento-prueba","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.3.1 Particion de entrenamiento /prueba","text":"Se prepara la validación del modelo. La serie se divide en y_train y y_test. Es crucial en series de tiempo usar window() y un muestreo aleatorio, ya que el orden temporal debe preservarse.","code":"\nh_test <- min(365, floor(length(y_hw)*0.2))  # 1 año o ~20% si no alcanza\nn <- length(y_hw)\ny_train <- window(y_hw, end = time(y_hw)[n - h_test])\ny_test  <- window(y_hw, start = time(y_hw)[n - h_test + 1])\n\nautoplot(y_hw) +\n  geom_vline(xintercept = time(y_hw)[n - h_test + 1], linetype = 2) +\n  labs(title = \"Serie completa con corte train/test\",\n       y = \"Precio promedio\", x = \"Tiempo\") +\n  theme_minimal()"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"agregación-semanal","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.3.2 Agregación semanal","text":"Modelar una estacionalidad de 365 períodos es computacionalmente inviable y estadísticamente inestable para HoltWinters o ets. Mediante la agregación de los datos una frecuencia menor que aún capture la estacionalidad (en este caso se escogió semanal el problema de soluciona, generando una nueva ts semanal y se aplica nuevamente la división de los datos en train y test","code":"\nlibrary(zoo)\n\n# y_hw: serie ts diaria (freq=365)\nstopifnot(frequency(y_hw) %in% c(365, 366))\n\n#secuencia de fechas real para la ts diaria\ntsp_hw <- tsp(y_hw)                     # c(start, end, freq)\nstart_year <- floor(tsp_hw[1])\nstart_frac <- tsp_hw[1] - start_year\nstart_date <- as.Date(paste0(start_year, \"-01-01\")) + round(start_frac * 365.25)\n\nfechas_all <- seq.Date(from = start_date, by = \"day\", length.out = length(y_hw))\nz_all <- zoo(as.numeric(y_hw), fechas_all)\n\n#Agregar por semana calendario\nz_week <- aggregate(z_all, as.Date(cut(index(z_all), \"week\")), mean, na.rm = TRUE)\n\n#Convertimos a ts semanal (freq = 52)\ny_w <- ts(as.numeric(z_week), frequency = 52)\n\n#Split train/test semanal\nh_test_w <- min(52, floor(length(y_w) * 0.2))\nn_w <- length(y_w)\ny_train_w <- window(y_w, end = time(y_w)[n_w - h_test_w])\ny_test_w  <- window(y_w, start = time(y_w)[n_w - h_test_w + 1])\n\nautoplot(y_w) +\n  geom_vline(xintercept = time(y_w)[n_w - h_test_w + 1], linetype = 2) +\n  labs(title = \"Serie semanal con corte train/test\",\n       y = \"Precio promedio semanal\", x = \"Tiempo\") +\n  theme_minimal()"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"modelos-de-suavizamiento-y-holt-winters-en-serie-semanal","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.3.3 Modelos de suavizamiento y Holt-Winters en serie semanal","text":"Se ajustan cuatro modelos de suavizamiento exponencial al conjunto de entrenamiento semanal (y_train_w).Se evaluán los modelos ANN más conocido como SES (Error Aditivo, sin tendencia, sin estacionalidad). Por otra parte el modelo Holt es un modelo con Error Aditivo, Tendencia Aditiva y sin Estacionalidad. Y por último, el modelo HoltWinters es un modelo completo que asume que la estacionalidad es constante.","code":"\n# Horizonte de prueba\nh <- length(y_test_w)\n\n# Modelos de suavizamiento base\n# Suavizamiento exponencial simple (SES)\nfit_ses_w <- ets(y_train_w, model = \"ANN\")\nfc_ses_w  <- forecast(fit_ses_w, h = h)\n\n# Holt: tendencia aditiva\nfit_holt_w <- ets(y_train_w, model = \"AAN\")\nfc_holt_w  <- forecast(fit_holt_w, h = h)\n\n# Holt-Winters con función base stats::HoltWinters\nfit_hwa_w <- HoltWinters(y_train_w, seasonal = \"additive\")\nfit_hwm_w <- HoltWinters(y_train_w, seasonal = \"multiplicative\")\n\n# Generar pronósticos a h pasos\nfc_hwa_w <- forecast(fit_hwa_w, h = h)\nfc_hwm_w <- forecast(fit_hwm_w, h = h)\n\n# Resumen de parámetros de suavizamiento\npars_w <- list(\n  SES      = fit_ses_w$par,\n  Holt     = fit_holt_w$par,\n  HW_adi   = fit_hwa_w$coefficients,\n  HW_multi = fit_hwm_w$coefficients\n)\n\nmetodos_w <- c(\n  SES    = fit_ses_w$method,\n  Holt   = fit_holt_w$method,\n  HW_adi = \"Holt-Winters aditivo (HoltWinters)\",\n  HW_mul = \"Holt-Winters multiplicativo (HoltWinters)\"\n)\n\nlist(pars = pars_w, metodos = metodos_w)## $pars\n## $pars$SES\n##      alpha          l \n##  0.9998999 20.0661412 \n## \n## $pars$Holt\n##      alpha       beta        phi          l          b \n##  0.9998998  0.1131366  0.8000015 19.3507661  0.7318030 \n## \n## $pars$HW_adi\n##            a            b           s1           s2           s3           s4 \n##  39.08244375   0.07882721  -7.65617219  -5.33129937  -2.12172776  -0.60521373 \n##           s5           s6           s7           s8           s9          s10 \n##   1.67227131   3.70855086   3.86297747   4.29730738   4.70950257   5.51286110 \n##          s11          s12          s13          s14          s15          s16 \n##   6.58108183   9.34052131  11.67282675  11.56985459  10.72690049  10.62915737 \n##          s17          s18          s19          s20          s21          s22 \n##  11.56624926  14.32396189  12.96493891  12.91210622  15.60833595  19.70484488 \n##          s23          s24          s25          s26          s27          s28 \n##  18.21542017  15.04288451   8.57289145   4.41893044   3.59468994   2.26948285 \n##          s29          s30          s31          s32          s33          s34 \n##   1.41348224   1.16589200   0.07345107  -2.59161738  -5.38569070  -6.81747767 \n##          s35          s36          s37          s38          s39          s40 \n##  -8.35116126 -10.31002086 -14.36805886 -15.48013931 -13.59119371 -14.10375330 \n##          s41          s42          s43          s44          s45          s46 \n## -12.98609882 -13.91879059 -12.80762063 -12.45344901 -10.91079687  -9.50278976 \n##          s47          s48          s49          s50          s51          s52 \n##  -7.48181474  -7.63951511  -9.66359895  -9.41494901  -8.19836375  -8.36815804 \n## \n## $pars$HW_multi\n##           a           b          s1          s2          s3          s4 \n## 40.06957603  0.07882721  0.78984647  0.86149189  0.95592829  0.99520880 \n##          s5          s6          s7          s8          s9         s10 \n##  1.06150922  1.11859277  1.10742123  1.11547832  1.13362719  1.15295252 \n##         s11         s12         s13         s14         s15         s16 \n##  1.19755872  1.28051297  1.34512974  1.33136792  1.29845693  1.29564795 \n##         s17         s18         s19         s20         s21         s22 \n##  1.31337013  1.37966490  1.36129664  1.37542631  1.45910223  1.55273805 \n##         s23         s24         s25         s26         s27         s28 \n##  1.49801968  1.41880910  1.25803359  1.12986066  1.10809063  1.06878253 \n##         s29         s30         s31         s32         s33         s34 \n##  1.05012792  1.03448499  1.00251606  0.92562241  0.84794487  0.78549769 \n##         s35         s36         s37         s38         s39         s40 \n##  0.73966473  0.68969443  0.59218461  0.55743071  0.58537805  0.58407654 \n##         s41         s42         s43         s44         s45         s46 \n##  0.61227139  0.60444293  0.63415394  0.64018299  0.67488001  0.72564177 \n##         s47         s48         s49         s50         s51         s52 \n##  0.78927007  0.78769837  0.73692250  0.74269354  0.77194581  0.76652385 \n## \n## \n## $metodos\n##                                         SES \n##                                \"ETS(A,N,N)\" \n##                                        Holt \n##                               \"ETS(A,Ad,N)\" \n##                                      HW_adi \n##        \"Holt-Winters aditivo (HoltWinters)\" \n##                                      HW_mul \n## \"Holt-Winters multiplicativo (HoltWinters)\""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"comparación-de-precisión-fuera-de-muestra","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.3.4 Comparación de precisión fuera de muestra","text":"Se calcula la precisión de los pronósticos de cada modelo contra los datos reales y_test_w. Se comparan las métricas de error (RMSE, MAE, MAPE) del conjunto de prueba.El modelo Holt-Winters multiplicativo (HW_mul) es el mejor, porque presenta los errores más bajos (RMSE y MAPE) en la ventana de prueba.\nEsto indica que la estacionalidad es proporcional al nivel de la serie (los picos crecen cuando el nivel general sube), lo cual es consistente con lo que se veia en el grafico.","code":"\n# Calcular métricas de error para cada modelo en el conjunto de prueba\nacc_tbl <- bind_rows(\n  data.frame(model = \"SES\",    accuracy(fc_ses_w,  y_test_w)),\n  data.frame(model = \"Holt\",   accuracy(fc_holt_w, y_test_w)),\n  data.frame(model = \"HW_adi\", accuracy(fc_hwa_w,  y_test_w)),\n  data.frame(model = \"HW_mul\", accuracy(fc_hwm_w,  y_test_w))\n) %>%\n  select(model, RMSE, MAE, MAPE)\n\nacc_tbl##                   model      RMSE       MAE      MAPE\n## Training set...1    SES  2.929804  1.928708  5.748854\n## Test set...2        SES 33.778723 24.276695 34.505452\n## Training set...3   Holt  2.902352  1.901817  5.638535\n## Test set...4       Holt 34.593228 24.973105 35.456690\n## Training set...5 HW_adi  2.984060  2.102575  6.453931\n## Test set...6     HW_adi 20.668712 14.555681 20.798164\n## Training set...7 HW_mul  2.846973  1.996849  6.036061\n## Test set...8     HW_mul 18.997168 13.487363 19.577035"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"diagnostico-de-residuos","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.3.5 Diagnostico de residuos","text":"Se realizarán dos pruebas estadísticas al pronóstico ganador. Por una parte el Gráfico ACF de Residuos, muestra la autocorrelación de los errores del modelo. Idealmente, ningún rezago debe superar las líneas azules. Esto significaría que los errores son “ruido blanco” y que el modelo ha capturado toda la información predecible.En segundo lugar, la Prueba Ljung-Box es la prueba estadística formal para la autocorrelación de los residuos.Hipótesis Nula (H_0): Los residuos son independientes (son ruido blanco).Al comparar los modelos de suavizamiento, Holt y Holt-Winters, se encontró que el Holt-Winters multiplicativo obtuvo los mejores resultados en la ventana de prueba, con los menores valores de RMSE (18.99) y MAPE (19.57 %).\nEsto indica que la serie presenta una estacionalidad proporcional al nivel, es decir, las fluctuaciones son más amplias cuando los valores son altos.El análisis de residuos respalda la adecuación del modelo: el p-valor = 0.1029 del test de Ljung-Box confirma que existe autocorrelación significativa (residuos ≈ ruido blanco).\nPor tanto, el modelo Holt-Winters multiplicativo logra capturar adecuadamente la tendencia y la estacionalidad de la serie semanal del precio promedio del Potato Red.","code":"\nbest_fc <- fc_hwm_w  # ganador: Holt-Winters multiplicativo\ncheckresiduals(best_fc$model)## \n##  Ljung-Box test\n## \n## data:  Residuals from HoltWinters\n## Q* = 76.422, df = 62, p-value = 0.1029\n## \n## Model df: 0.   Total lags used: 62"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"pronostico-final","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.3.6 Pronostico final","text":"Reentrenamiento: Ahora que hemos probado que el modelo HW Multiplicativo es el mejor, lo reentrenamos usando todos los datos semanales (y_w), solo el conjunto de entrenamiento. Esto le da al modelo la mayor cantidad de información posible para estimar los parámetros finales.Reentrenamiento: Ahora que hemos probado que el modelo HW Multiplicativo es el mejor, lo reentrenamos usando todos los datos semanales (y_w), solo el conjunto de entrenamiento. Esto le da al modelo la mayor cantidad de información posible para estimar los parámetros finales.Pronóstico: Se genera el pronóstico final hacia el futuro (h = 52 semanas, un año).Pronóstico: Se genera el pronóstico final hacia el futuro (h = 52 semanas, un año).","code":"\n# Reentrenar el modelo Holt-Winters multiplicativo con toda la serie semanal\nfit_final_hw <- HoltWinters(y_w, seasonal = \"multiplicative\")\n\n# pronóstico a 52 semanas (≈ 1 año)\nh_future <- 52\nfc_final_hw <- forecast(fit_final_hw, h = h_future)\n\n# Visualizacion del pronóstico final\nautoplot(fc_final_hw) +\n  labs(\n    title = \"Pronostico final Holt-Winters multiplicativo (52 semanas)\",\n    y = \"Precio promedio semanal\",\n    x = \"Tiempo\"\n  ) +\n  theme_minimal()\n# primeras filas de la tabla de pronostico\nhead(data.frame(\n  Semana = time(fc_final_hw$mean),\n  Pronostico = round(as.numeric(fc_final_hw$mean), 2),\n  LI_80 = round(fc_final_hw$lower[,1], 2),\n  LS_80 = round(fc_final_hw$upper[,1], 2),\n  LI_95 = round(fc_final_hw$lower[,2], 2),\n  LS_95 = round(fc_final_hw$upper[,2], 2)\n), 10)##      Semana Pronostico LI_80 LS_80 LI_95 LS_95\n## 1  8.961538      37.69 33.31 42.07 30.99 44.39\n## 2  8.980769      40.88 35.05 46.72 31.96 49.81\n## 3  9.000000      45.08 37.83 52.33 33.99 56.16\n## 4  9.019231      47.46 39.09 55.83 34.66 60.26\n## 5  9.038462      50.77 41.19 60.34 36.13 65.41\n## 6  9.057692      55.25 44.31 66.19 38.52 71.98\n## 7  9.076923      55.96 44.35 67.58 38.20 73.73\n## 8  9.096154      55.31 43.30 67.32 36.95 73.67\n## 9  9.115385      55.66 43.09 68.24 36.43 74.90\n## 10 9.134615      58.37 44.76 71.99 37.55 79.20"},{"path":"pronóstico-de-demanda-holtwinters.html","id":"conclusiones","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.3.7 Conclusiones","text":"Tras evaluar diferentes métodos de suavizamiento exponencial, se determinó que el modelo Holt-Winters multiplicativo fue el que presentó el mejor desempeño predictivo, con los menores errores (RMSE = 18.99 y MAPE = 19.6 %) en la ventana de prueba.Este resultado confirma que la serie presenta estacionalidad proporcional al nivel, es decir, cuando el precio promedio del Potato Red aumenta, las fluctuaciones también lo hacen en la misma proporción.Los residuos del modelo mostraron autocorrelación significativa (p-valor = 0.1029), por lo que se concluye que el modelo explica adecuadamente la estructura temporal.Con la serie completa y el modelo reentrenado, el pronóstico 52 semanas muestra una tendencia oscilante con picos regulares y amplitud similar la observada históricamente.\nLas bandas de confianza (80 % y 95 %) reflejan un nivel de incertidumbre moderado, lo que otorga confianza en las estimaciones.En conjunto, el método Holt-Winters multiplicativo demuestra ser una herramienta sólida y confiable para proyectar el comportamiento estacional del precio semanal del Potato Red.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"desarrollo-metodológico-y-justificación-de-decisiones","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.4 Desarrollo metodológico y justificación de decisiones","text":"El proceso de aplicación del modelo de Holt-Winters la serie de tiempo del precio promedio del Potato Red implicó diversos ajustes metodológicos debido las características particulares de los datos.\nLa variable de estudio correspondía una serie diaria con una extensión superior 2800 observaciones y frecuencia anual de 365. Si bien esta cantidad de datos representaba una fuente valiosa de información, también generó limitaciones computacionales al momento de ajustar modelos estacionales como ets(model = “AAA”) o hw(seasonal = “additive”), debido que la función ets()` está optimizada para manejar estacionalidades tan largas.Durante los primeros intentos, el software arrojó el error “Frequency high” o se quedaba ejecutando indefinidamente. Esto motivó una revisión del enfoque, identificando que la estacionalidad de interés necesariamente se presentaba de manera diaria, sino más bien en ciclos semanales o mensuales, propios de los precios agrícolas.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"ajuste-de-la-frecuencia-temporal","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.4.1 Ajuste de la frecuencia temporal","text":"Como solución, se decidió agregar la serie frecuencia semanal, calculando el promedio de los precios diarios.\nEsta decisión permitió conservar la forma cíclica de la serie (picos y valles regulares) y, al mismo tiempo, reducir la frecuencia de 365 52, lo cual hizo posible aplicar modelos estacionales de forma estable y con un tiempo de cómputo razonable.\nEn la práctica, esto significó reconstruir la serie con una frecuencia semanal (frequency = 52), evitando la sobrecarga que impedía el ajuste de Holt-Winters en la versión original.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"modelos-aplicados","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.4.2 Modelos aplicados","text":"Una vez ajustada la frecuencia, se implementaron cuatro modelos de suavizamiento:Suavizamiento exponencial simple (SES) – Captura únicamente el nivel de la serie.Método de Holt – Incorpora tendencia aditiva.Holt-Winters aditivo – Considera tendencia y estacionalidad de amplitud constante.Holt-Winters multiplicativo – Considera estacionalidad proporcional al nivel.Debido los errores recurrentes con ets() y hw(), se optó finalmente por la función stats::HoltWinters(), que permite ajustar modelos estacionales de manera más estable con series largas o de alta frecuencia.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"validación-del-modelo","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.4.3 Validación del modelo","text":"La serie semanal se dividió en un conjunto de entrenamiento (80%) y otro de prueba (20%), correspondiente aproximadamente un año de observaciones.\nCon esta división, se evaluó el desempeño predictivo de cada modelo mediante métricas como RMSE, MAE y MAPE.Los resultados mostraron que el modelo Holt-Winters multiplicativo presentó el mejor desempeño (RMSE = 18.99, MAPE = 19.6%), superando las versiones aditiva, Holt y SES.\nEsto indica que la estacionalidad es proporcional al nivel de la serie: cuando los precios son altos, las fluctuaciones semanales también lo son.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"diagnóstico-de-residuos","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.4.4 Diagnóstico de residuos","text":"Para validar el ajuste, se analizaron los residuos del modelo Holt-Winters multiplicativo.\nEl test de Ljung-Box (p-valor = 0.1029) indicó ausencia de autocorrelación significativa, lo cual demuestra que el modelo logra capturar adecuadamente la tendencia y la estacionalidad de los datos.\nAdemás, el gráfico ACF de los residuos mostró patrones sistemáticos, confirmando que el error se comporta como ruido blanco.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"pronóstico-final","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.4.5 Pronóstico final","text":"Con base en el modelo seleccionado, se reentrenó la serie completa y se realizó un pronóstico 52 semanas (equivalente un año).\nEl resultado mostró una evolución oscilante, con picos estacionales regulares y una amplitud coherente con los patrones históricos observados.\nLas bandas de confianza del 80% y 95% se mantuvieron en rangos moderados, reflejando un nivel de incertidumbre aceptable.","code":""},{"path":"pronóstico-de-demanda-holtwinters.html","id":"conclusión-integradora","chapter":"Capítulo 3 Pronóstico de Demanda HoltWinters","heading":"3.4.6 Conclusión integradora","text":"En síntesis, el desarrollo de este modelo implicó un proceso iterativo de ajuste y validación.\nSe comprobó que aplicar Holt-Winters directamente sobre la serie diaria era impracticable por su frecuencia alta, por lo que fue necesario agregar la serie frecuencia semanal para estabilizar el modelo.\nEste cambio permitió aplicar el método de forma exitosa y obtener resultados coherentes, concluyendo que el modelo Holt-Winters multiplicativo es una herramienta sólida para pronosticar el comportamiento estacional del precio del Potato Red, combinando buena precisión y consistencia temporal.","code":""}]
